<div class = "container-fluid mt-2">
    <div class="row">
        <sprint-side-menu></sprint-side-menu>
        <div class="col-md-10">
            <a href="#!/integration/119" class="nav-link">Integration-119</a>
            <a target= "_blank" href="https://www.youtube.com/watch?v=1EJ2aRlfXUM&list=PLMEYlt-BRJcJUUFSUjULJSSUZRbvFALhQ" class="nav-link">demo-playlist</a>
            <a href="#!/project/103" class="nav-link">project-estoreexpress</a>
            <div class="grooveborder">
                <h6 class="text-center">ESTORE-SPRITE-J1<span class="alignright"><strong>github repository: </strong><a href="https://github.com/madajee/e-store-express-mule.git" target="_blank">e-store-express-mule</a></span></h6>
                <h3>e-store-express-mule: <i>sprite.j1</i></h3>
                <p>As a experience api, I should able to register and login with this Mule API. Let's just start with a POC guy velocity of about 18 points.<br>Tools: [Anypoint Studio, Postman]<br>
                    <h4>Features: [Register, Login]</h4>
                    <ul>
                        <li><strong>Card-1: </strong>Scaffold an e-store-express-mule application using standard muledev practices with 3 mule configuration files, one with APIkit router that gets generated from RAML API specification, second for the global configuration and third for authentication and supporting flows.</li>
                        <li><strong>Card-2: </strong>Add the POST for register endpoint and use the mule generate flow feature (APIkit router) to generate the interface flow. We also need to test the generated flow with the request and response in the raml api spec. Request can be as simple as a username, password and name.</li>
                        <li><strong>Card-3: </strong>Add the POST for login endpoint and use the mule generate flow feature (APIkit router) to generate the interface flow. Test the generated flow. Request can be as simple as a username, password.</li>
                        <li><strong>Card-4: </strong>POC with Mule 4 OAuth2 provider with provider config, 2 default object store for client, token. Understand the provider operations like create client, delete client, validate token.</li>
                        <li><strong>Card-5: </strong>Create a collection for e-store-express-mule with login and register endpoint.</li>
                        <li><strong>Card-6: </strong>About 10 days between Jan 8 to Jan 20</li>
                    </ul>
                </p>
            </div>
            <div class="grooveborder">
                <h6 class="text-center">ESTORE-COLA-F1<span class="alignright"><strong>github repository: </strong><a href="https://github.com/madajee/estoreexpress-subscriberapi-mule.git" target="_blank">estoreexpress-subscriberapi-mule</a></span></h6>
                <h3>estoreexpress-subscriberapi-mule: <i>cola.f1</i></h3>
                <p>As a system api, I should able persist the user registration in users table.<br>Tools: [Anypoint Studio, Postman]<br>
                    <h4>Features: [Register, Login]</h4>
                    <ul>
                        <li><strong>Card-1: </strong>Add a non persistent user queue and enable pub-sub with mule vm connector. Use msgtype as register, login for messages in userq.</li>
                        <li><strong>Card-2: </strong>Setup postgres or the database of choice like mysql in the local environment. Create an e-store-express database and a user table.</li>
                        <li><strong>Card-3: </strong>Create the CRUD raml for the users table and scaffold a mule project as estoreexpress-subscriberapi-mule. Use the apikit router and raml to generate the api interface</li>
                        <li><strong>Card-4: </strong>Use the mule DB connector and test CRUD api for users.</li>
                        <li><strong>Card-5: </strong>Create a collection for estoreexpress-subscriberapi-mule for the createuser endpoint.</li>
                        <li><strong>Card-6: </strong>About 10 days between Jan 28 to Feb 10</li>
                    </ul>
                </p>
            </div>
            <div class="grooveborder">
                <h6 class="text-center">ESTORE-FANTA-F2<span class="alignright"><strong>github repository: </strong><a href="https://github.com/madajee/estoreexpress-subscriberapi-mule.git" target="_blank">estoreexpress-subscriberapi-mule</a></span></h6>
                <h3>e-store-express-mule: <i>fanta.f2</i></h3>
                <p>Keeping POC aside, effort should also go into learning with online community videos.<br>Tools: [Anypoint Studio, mule community channels]<br>
                    <h4>Features: [Deployment Options, Error Handling]</h4>
                    <ul>
                        <li><strong>Card-1: </strong>[Mule Applications Coverage]: Advance mule coverage understanding by watching mule community videos, training session. Add short notes in each sprint.</li>
                        <li><strong>Card-2: </strong>Create a common error handler that can be copied and tailored across projects. Scaffold the flow with multiple Error Propage scope for few error types and the bottom one should be for ANY Error Type.</li>
                        <li><strong>Card-3: </strong>Create a canonical error dwl that should create a error payload using the error object.</li>
                        <li><strong>Card-4: </strong>Create the configuration element to specify common error handler as default error handler and test for couple of error on the OAuth components.</li>
                        <li><strong>Card-5: </strong>Create the errorq for error payload along with common publish subflow which can be referenced from On Error Propagate scopes of Common Error Handler.</li>
                        <li><strong>Card-6: </strong>About 10 days between Feb 18 to Mar 2</li>
                    </ul>
                </p>
            </div>
            <div class="grooveborder">
                <h6 class="text-center">ESTORE-LATTE-M1<span class="alignright"><strong>github repository: </strong><a href="https://github.com/madajee/estoreexpress-subscriberapi-mule.git" target="_blank">estoreexpress-subscriberapi-mule</a></span></h6>
                <h3>e-store-express-mule: <i>latte.m1</i></h3>
                <p>Focus on videos with architecture content.<br>Tools: [Anypoint Studio, NodeJS, YouTube videos]<br>
                    <h4>Features: [Architecture Coverage, Error Handling]</h4>
                    <ul>
                        <li><strong>Card-1: </strong>[Architecture Coverage]: Advance architecture understanding by listening to videos that has architecture asides. Similar to [Mule Coverage] card started in fanta.f2, cards like these will follow continum style of moving across sprints.</li>
                        <li><strong>Card-2: </strong>Add the correlationId in the e-store-express-mule app. First test with mapping correlationId to TransactionId in the response for one of the endpoint. Explore configuration to generate custom correlationId and also use the tracing module vm publish flow to add username along with correlationId while mapping to transactionId.</li>
                        <li><strong>Card-3: </strong>n the e-store-express-mule app, we will get an error when the register endpoint is called twice with the same username as the first call will create the client in the OAuth provider. [Error Type: OAUTH2-PROVIDER:CLIENT_ALREADY_EXISTS, Message: The client with ID: test1 is already registered]. Publish the error to the errorq with the transactionId (set as correlationId) and msgtype (set as register).
                        {"transactionId":"9e56521b.ec30.4709.b477.c743f3854063","msgtype":"register","transactionstatus":"Failed","error":{"description":"The client with ID: test1 is already registered","type":"APPERROR:CLIENT_ALREADY_EXISTS","cause":"The client with ID: test1 is already registered"}}</li>
                        <li><strong>Card-4: </strong>In the “estoreexpress-subscriberapi-mule”, add the listener flow for the errorq and test for "transactionId":"9e56521b.ec30.4709.b477.c743f3854063" from card-4. Log the error with the logger component but as we move along we will have to persist these kind of errors from the queue.</li>
                        <li><strong>Card-5: </strong>Start dev in NodeJS by scaffolding e-store-express with npm init; require express module; log port in the callback function of express app listen method. Use require on config file to read the port property.</li>
                        <li><strong>Card-6: </strong>About 10 days between Mar 10 to Mar 23.</li>
                    </ul>
                </p>
            </div>
            <div class="grooveborder">
                <h6 class="text-center">ESTORE-MOCHA-M2<span class="alignright"><strong>github repository: </strong><a href="https://github.com/madajee/e-store-express.git" target="_blank">e-store-express-node</a>
                    <a href="https://github.com/madajee/estoreexpress-errorapi-mule.git" target="_blank">estoreexpress-errorapi-mule</a></span></h6>
                <h3>e-store-express: <i>mocha.m2</i></h3>
                <p>user routes and controller in nodejs and mule error-api.<br>Tools: [Anypoint Studio, NodeJS]<br>
                    <h4>Features: [nodejs, mule error-api]</h4>
                    <ul>
                        <li><strong>Card-1: </strong>Now that we have express server listening in estore node app, develop the signup and login routes and controllers. Both register and login are post and payload should be validated using the ajv (another json validator) and check() method should be called as an express middleware.</li>
                        <li><strong>Card-2: </strong>Use sequelize ORM module along with pg to connect to estore database and initialize the user model.</li>
                        <li><strong>Card-3: </strong>Create utility method in authorization controller for generateAccessToken() and encryptPassword() using jsonwebtoken and crypto modules. Initialize the User model and persist the user with createuser() in the signup route with encrypted password and return the token in response.</li>
                        <li><strong>Card-4: </strong>In the login controller, retrieve the user, perform password validation and in case of successful validation, return the token in reposne, else throw an error. Add the user associated with generated token in the request.</li>
                        <li><strong>Card-5: </strong>Create and test the [/user/all] route with user route and controller js files which will chain getAllUsers() in controller layer to findAllUsers() in the model layer.</li>
                        <li><strong>Card-6: </strong>Scaffold an estoreexpress-errorapi-mule and write errors in a errors db table and estoreexpress-errors.csv.</li>
                        <li><strong>Card-7: </strong>About 10 days between Mar 31 to Apr 13.</li>
                    </ul>
                </p>
            </div>
            <div class="grooveborder">
                <h6 class="text-center">ESTORE-Cappuccino-A1<span class="alignright"><strong>github repository: </strong><a href="https://github.com/madajee/e-store-express.git" target="_blank">e-store-express-node</a>
                    <a href="https://github.com/madajee/estoreexpress-errorapi-mule.git" target="_blank">estoreexpress-errorapi-mule</a></span></h6>
                <h3>e-store-express: <i>cappuccino.a1</i></h3>
                <p>product routes and controller in nodejs and product crud api in estoreexpress-subscriberapi-mule.<br>Tools: [Anypoint Studio, NodeJS]<br>
                    <h4>Features: [product api in nodejs and mule]</h4>
                    <ul>
                        <li><strong>Card-1: </strong>Create the controller and routes for products. Product model will vary as per the domain but for the node POC, one can use attributes like id, name and description.</li>
                        <li><strong>Card-2: </strong>Add the product routes for getallproducts() and createProduct().</li>
                        <li><strong>Card-3: </strong>Use the example to create the table in postgres for estore-exprepss-mule database.
                            <pre>
                                <code>
{
    id: 2,
    title: "iPhone X",
    description: "SIM-Free, Model A19211 6.5-inch Super Retina HD display with OLED technology A12 Bionic chip with ...",
    price: 899,
    discountPercentage: 17.94,
    rating: 4.44,
    stock: 34,
    brand: "Apple",
    category: "smartphones",
    thumbnail: "https://www.publicdomainpictures.net/pictures/10000/velka/1-1210009435EGmE.jpg"
}                                 </code>
                            </pre>
                        </li>
                        <li><strong>Card-4: </strong>In the estoreexpress-subscriberapi-mule, add the estoreexpress-services-product.xml file and create the products crud api.</li>
                        <li><strong>Card-5: </strong>About 10 days between Apr 21 to May 4.</li>
                    </ul>
                </p>
            </div>
            <div class="grooveborder">
                <h6 class="text-center">ESTORE-SCHWEPPES-M(X)1<span class="alignright"><strong>github repository: </strong><a href="https://github.com/madajee/e-store-express.git" target="_blank">e-store-express-node</a>
                    <a href="https://github.com/madajee/estoreexpress-subscriberapi-mule.git" target="_blank">estoreexpress-subscriberapi-mule</a></span></h6>
                <h3>e-store-express: <i>schweppes.mx1</i></h3>
                <p><strong>Context:</strong>We have covered quite a bit of ground on both node and mule side with user tokens in register and login, pub-sub and api driven calls, persisting sample product to db, but now we want to push a bit on order feature.<p>
                    <h4>Features: [order and orderitems]</h4>
                    <ul>
                        <li><strong>Card-1: </strong>On the node side, create the controller and routes for orders and orderitems, and we should able to create an order for the user. <pre>
                            <code> 
                            // Order model relations
                            Order.belongsTo(User);
                            Order.belongsToMany(Product, {through: OrderItem});
                            Product.belongsToMany(Order, {through: OrderItem});
                            </code>                    
                        </pre> 
                        <pre>
                            <code> 
                              POST /order { "userId": "1"}
                            </code>                    
                        </pre></li>
                        <li><strong>Card-2: </strong>On the node side, after the order is created for the user, add routes for add product to an order and removing product from an order.<pre>
                            <code> 
                                POST /order/addorderproduct {"quantity": "3", "productId": "2"}
                            </code>                    
                        </pre>
                        <pre>
                            <code> 
                                POST /order/removeorderproduct {"productId": "2"}
                            </code>                    
                        </pre></li>
                        <li><strong>Card-3: </strong>On the mule side, create the order and orderitems table.<br>order: [id primary key, orderidentifier varchar unique not null, customername varchar not null, ordertype varchar not null, servicetype varchar not null, status varchar not null, startdate timestamp not null, enddate timestamp not null, audit fields]<br>orderitems: [id primary key, quantity integer, orderid as foreign key on orders, productid as foreignkey on products, unique(productid, orderid) audit fields]</li>
                        <li><strong>Card-4: </strong>On the mule side, create order which should persist order and orderitems records. Use bulk insert for order items. Enclose Both order and orderitems persistence in a transaction boundary with a TRY. 
                        <pre>
                            <code> 
                                POST /order
                                {
                                    "customername": "John Doe",
                                    "ordertype": "WEB",
                                    "servicetype": "Azure",
                                    "userid": "1",
                                    "orderitems": [
                                        {
                                            "productId": "1",
                                            "quantity": "1"
                                        },
                                        {
                                            "productId": "2",
                                            "quantity": "1"
                                        }
                                    ]
                                }
                            </code>                    
                        </pre></li>
                        <li><strong>Card-5: </strong>On the mule side, create a /orderdestroy endpoint which should delete the order and orderitems by passing in the orderidentifier. 
                        <pre>
                            <code> 
                                POST /orderdestroy
                                {
                                    "orderidentifier": "2fad1639-5fcb-4a15-a6c1-5a620cbce680"
                                }
                            </code>                    
                        </pre></li>
                        <li><strong>Card-6: </strong>Add the VM queue interface for orderq and test create order by publishing the message to the queue.</li>
                        <li><strong>Card-7: </strong>About 10 days between May 12 to May 25.</li>
                    </ul>
                </p>
            </div>
            <div class="grooveborder">
                <h6 class="text-center">ESTORE-DIETCOKE-J(X)1<span class="alignright"><strong>github repository: </strong><a href="https://github.com/madajee/estore-sfdc-system-api.git" target="_blank">estore-sfdc-system-api</a></h6>
                <h3>e-store-express: <i>dietcoke.jx1</i></h3>
                <p><strong>Context: </strong>With Level 1 view, we understand that store channel is self service style of customer onboarding and order capture but Sales Cloud in Salesforce has Lead To Cash process through which agents creates customers by converting leads and quotes in CPQ allows them to manage a deal before order capture stage. 
                    <ul>
                        <li><a href="#!/sprint/2" target="_blank">Level-1 view</a></li>
                        <li><a href="https://trailhead.salesforce.com/content/learn/projects/manage-products-prices-quotes-orders" target="_blank">manage-products-prices-quotes-orders</a></li>
                    </ul>
                <p>
                <h4>Features: [lead automation and conversion]</h4>
                <ul>
                    <li><strong>Card-1: </strong>On the mule side, we are going to scaffold estore-sfdc-system-api, and establish the connectivity using the mule connector with the sandbox org and salesforce provides with the signup using a personal email address.</li>  
                    <li><strong>Card-2: </strong>Create an endpoint with lead resource and POST method so that we can create the lead in the sfdc org with the create operation in salesforce connector.
                        <pre>
                            <code> 
                                POST /lead
                                [
                                    {
                                        "firstname": "John",
                                        "lastname": "Doe",
                                        "company": "XYZEnterprise",
                                        "status": "Open",
                                        "title": "Account Executive"
                                    },
                                    {
                                        "firstname": "Jane",
                                        "lastname": "Doe",
                                        "company": "XYZEnterprise",
                                        "status": "Open",
                                        "title": "Account Analyst"
                                    },
                                    {
                                        "firstname": "Jack",
                                        "lastname": "Doe",
                                        "company": "XYZEnterprise",
                                        "status": "Open",
                                        "title": "Account Developer"
                                    }
                                ]
                            </code>                    
                        </pre>
                    </li>
                    <li><strong>Card-3: </strong>Add another endpoint on the lead resource and GET method with couple of query params as leadname and company. Use the connector Query operation to query the created leads with company or leadname. When both query params are null, retrieve the 10 leads with LIMIT 10.</li>
                    <li><strong>Card-4: </strong>Add deleteleads resource with a POST method and input as an array of IDs and use the delete operation of the connector to delete the leads.</li>
                    <li><strong>Card-5: </strong>Add the convertlead resource with a POST method which will query the lead with a leadname and uses the Convert Lead operation of the connector to create the account and contacts. Optionally an opportunity can be created with a doNotCreateOpportunity flag. Also test with a delete resource where you pass in the converted account id and all dependent objects are deleted.
                        <pre>
                            <code> 
                                POST /convertlead
                                {
                                    "name": "John Doe",
                                    "leadsource": "web",
                                    "doNotCreateOpportunity": true
                                }
                            </code>                    
                        </pre>
                    </li>
                    <li><strong>Card-6: </strong>Create a trailhead playground for the trailhead project of manage products, prices, quotes and orders and test connectivity in mule salesforce connector to playground org along with sandbox org.</li>
                    <li><strong>Card-7: </strong>About 10 days between June 2 to June 15.</li>
                </ul>
            </div>
            <div class="grooveborder">
                <h6 class="text-center">ESTORE-WALKING_JOGGER-JX1<span class="alignright"><strong>github repository: </strong><a href="https://github.com/madajee/estore-sfdc-system-api.git" target="_blank">estore-sfdc-system-api</a></h6>
                <h3>e-store-express: <i>walkingjogger.jx1</i></h3>
                <strong>Context: </strong>In dietcoke sprint, we developed mule integration with lead object and the automation allow us to create lead and the /convertlead endpoint enable has to create account, contact and opportunities. We will now work on automating the products and pricebooks. As we follow trailhead project: <a target= "_blank" href="https://trailhead.salesforce.com/content/learn/projects/manage-products-prices-quotes-orders" class="nav-link">Manage Products, Prices, Quotes, and Orders</a> the automation on product and pricebook will enable us to verify trailstep: <i>Create and Customize Products,</i> <i>Create Custom Price Books</i> with mule integration.
                <ul>
                    <li>
                        Product2 is the salesforce object for persisting product records.
                    </li>
                    <li>
                        Pricebooks is created with header-detail object style with header object as Pricebook2 and pricebook entries in detail object as PricebookEntry.
                    </li>
                    <li>
                        Pricebook entries are identified with PricebookId, product code and currency code. We can retrieved the pricenookId from header table pricebook name (eg: Standard Price Book, Entperprise, Nonprofit)
                    </li>
                </ul>
                <h4>Features: [Products, Pricebook]</h4>
                <ul>
                    <li><strong>Card-0: </strong><a href="#!/sprint/4" class="nav-link">BACKLOG-ZONE-JULY-1 AND BACKLOG-ZONE-JULY-2</a></li>
                    <li><strong>Card-1: </strong>Spec for the trail step mentions 3 prodcuts [{Product Name: UMS Solar Panel Cleaning Residential, Product Code: SPC-R01},  {Product Name: SunPower Ground, Product Code: SPG-01}, {Product Name: GreenSun Ground, Product Code: SPG-02}] . Create a mule configuration file  product-obj in estore-sfdc-system-api and implement the resource POST /product.
                        <pre>
                            <code>
                                [
                                {
                                    "name": "UMS Solar Panel Cleaning Residential",
                                    "description": "Residential solar panel cleaning service package",
                                    "family": "Service Packages",
                                    "productcode": "SPC-R01",
                                    "productcurrency": "USD",
                                    "active": true
                            
                                },
                                {
                                    "name": "SunPower Ground",
                                    "description": "80-cell ground-mounted solar panel",
                                    "family": "Panels",
                                    "productcode": "SPG-01",
                                    "productcurrency": "USD",
                                    "active": true,
                                    "groundmount": true
                                },
                                {
                                    "name": "GreenSun Ground",
                                    "description": "60-cell ground-mounted solar panel",
                                    "family": "Panels",
                                    "productcode": "SPG-02",
                                    "productcurrency": "USD",
                                    "active": true,
                                    "groundmount": true
                                }
                            ]
                             </code>
                        </pre>
                    </li>
                    <li><strong>Card-2: </strong>Add the following get endpoints
                    <ul>
                        <li>
                            Retrieve products with Id
                        </li>
                        <li>
                            Retrieve products with product code list : Create the dynamic query with SQL IN operator in WHERE clause to pass the product codes and the value for IN clause can be created with dwl functions like map(), join() and  “++” operator.
                            <pre>
                                <code>
product code list: ["SPC-R01","SPG-01","SPG-02"] <br>
%dw 2.0
output application/java
var condition = "(" ++ ((payload.productcodelist map () -> "'" ++ $ ++ "'") joinBy (",")) ++ ")"
\---
{
"query" : "SELECT ID, Name, Description, Family, ProductCode, CurrencyIsoCode, IsActive FROM product2 where ProductCode IN "  ++ condition
}
                                 </code>
                            </pre> 
                        </li>
                    </ul>
                    </li>
                    <li><strong>Card-3: </strong>Add deleteleads resource with a  POST method and input as an array of IDs  and use the delete operation of the connector to delete the products.</li>
                    <li><strong>Card-4: </strong>We require Admin to create the Pricebook records but we expose an resource to create the pricebookentry. The request payload for pricebookentry object requires a Product2Id and Pricebook2Id. We require 2 lookup query, one to retrieve the pricebook2Id with pricebook name and other to retrieve the product2Id with Product Code.</li>
                    <li><strong>Card-5: </strong>Add the following get endpoints to retrieve the pricebook entry based on pricebook, product and currency code. This will be used to get the correct unit price as same product can have different price in different pricebook. Use the following dwl to create the dynamic query:
                        <pre>
                            <code>
%dw 2.0
output application/json
var condition1 = "select Id, Name, CurrencyIsoCode, UnitPrice, ProductCode, Pricebook2.Name from PricebookEntry"
var condition2 = " WHERE Pricebook2Id = " ++ "':pricebookid'"
var condition3 = " AND ProductCode = " ++ "':productcode'"
var condition4 = " AND CurrencyIsoCode = " ++ "':currencycode'"
var condition5 = " LIMIT 10"
var condition = condition1 ++ (if (vars.pricebook[0].Id != null) condition2 else '') ++ (if (vars.queryparameters.productcode != null) condition3 else '') ++ (if (vars.queryparameters.currencycode != null) condition4 else '') ++ (if (vars.queryparameters.productcode == null and vars.queryparameters.currencycode == null) condition5 else '')
---
{
"query" : condition
}
                                </code>
                        </pre>
                    </li>
                    <li><strong>Card-6: </strong>With these resources implemented, one should able to understand and finish both the trail steps: <i>Create and Customize Products,</i> <i>Create Custom Price Books</i>  and complete the verification step in the trailhead playground.</li>
                    <li><strong>Card-7: </strong>About 10 days between June 23 to July 6.</li>
                    <li><strong>Card-8: </strong>About 10 days between July 14 to July 27.</li>
                </ul>
            </div>
            <div class="grooveborder">
                <h6 class="text-center">ESTORE-JUMPING_JOGGER-AX1<span class="alignright"><strong>github repository: </strong><a href="https://github.com/madajee/estore-sfdc-system-api.git" target="_blank">estore-sfdc-system-api</a></h6>
                <h3>e-store-express: <i>jumpingjogger.ax1</i></h3>
                <strong>Context: </strong>In diet-coke, walking-jogger sprint, we created an account: Ursa Major Solar, Inc with lead object automation and also created a service package and 2 panels with product2 object automation that sales teams at UMS will sell. Along with standard pricebooks, we created Nonprofit and Enterprise pricebook and created pricebook entries in USD and JPY. The next step in the <a target= "_blank" href="https://trailhead.salesforce.com/content/learn/projects/manage-products-prices-quotes-orders" class="nav-link">Manage Products, Prices, Quotes, and Orders</a> is to automate <i>updates on opportunity,</i> <i>by adding opportunity products</i> with mule integration.
                <ul>
                    <li>
                        Opportunity is the salesforce object for persisting opportunity records and though we can create the opportunity record with UI, we will have an opportunity by converting the lead.
                    </li>
                    <li>
                        OpportunityLineItem is the salesforce object for persisting opportunity product records.
                    </li>
                </ul>
                <h4>Features: [Opportunity, Opportunity Products]</h4>
                <ul>
                    <li><strong>Card-0: </strong><a href="#!/sprint/4" class="nav-link">BACKLOG-ZONE-AUGUST</a></li>
                    <li><strong>Card-1: </strong>As per trail spec, we require 2 accounts (Boy Scouts of the Southwest, Saito - Ground-mounted Panels) and each account should have an opportunity.
                        <ul>
                            <li>
                                Boy Scouts of the Southwest will have an opportunity: BSofSW - Ground-mounted Panels.
                            </li>
                            <li>
                                Saito Family Laundromats will have an opportunity: Saito - Ground-mounted Panels.
                            </li>
                        </ul>
                        We will convert a lead: John Doe who works for Boy Scouts by passing in the opportunity name and donotcreateopportunity as false to create the opportunity.
<pre>
    <code>
        curl --location 'http://localhost:8081/api/convertlead' \
        --header 'Content-Type: application/json' \
        --data '{
            "name": "Jane Doe",
            "leadsource": "web",
            "doNotCreateOpportunity": false,
            "opportunityname": "Saito - Ground-mounted Panels"
        }'
        </code>
</pre>
<pre>
<code>
    curl --location 'http://localhost:8081/api/convertlead' \
    --header 'Content-Type: application/json' \
    --data '{
        "name": "John Doe",
        "leadsource": "web",
        "doNotCreateOpportunity": false,
        "opportunityname": "BSofSW - Ground-mounted Panels"
    }'
    </code>
</pre>
                    </li>
                    <li><strong>Card-2: </strong>We should able to query the created account and opportunity with lead conversion process. Add the opportunity-obj anc account-obj mule configuration file. Add the following get endpoints:
                        <ul>
                            <li>
                                opportunity by opportunity name
<pre>
    <code>
        curl --location 'http://localhost:8081/api/opportunity?opportunityname=Saito%20-%20Ground-mounted%20Panels'
        </code>
</pre>
                            </li>
                            <li>
                                account by account name.
<pre>
    <code>
        curl --location 'http://localhost:8081/api/account?accountname=Saito%20Family%20Laundromats'
        </code>
</pre> 
                            </li>
                        </ul>
                        </li>
                        <li><strong>Card-3: </strong>Saito Family Laundromats is operating as a Enterprise in Japan where as Boy Scout is operating as a Nonprofit, so we need to update the account currency to JPY. As per trail specs, we have enabled multicurrency amd setup JPY, SGD, GBP, EUR along with USD. Create a PUT endpoint to update account currency as JPY.
<pre>
    <code>
        curl --location --request PUT 'http://localhost:8081/api/account/{accountId}' \
        --header 'Content-Type: application/json' \
        --data '{
            "accountcurrency": "JPY"
        }'
        </code>
</pre>     
                        </li>
                        <li><strong>Card-4: </strong>Create a PUT endpoint to update opportunity to update the pricebook, currency and opportunity amount.
<pre>
    <code>
        Saito Family Laundromats

        curl --location --request PUT 'http://localhost:8081/api/opportunity/{opportunityId}' \
        --header 'Content-Type: application/json' \
        --data '{
            "opportunitypricebook": "Enterprise",
            "opportunitycurrency": "JPY",
            "opportunityamount": "4200000"
        
        }'
        </code>
</pre>
<pre>
    <code>
        Boy Scout

        curl --location --request PUT 'http://localhost:8081/api/opportunity/006bm000001oXrRAAU' \
        --header 'Content-Type: application/json' \
        --data '{
            "opportunitypricebook": "Nonprofit",
            "opportunitycurrency": "USD",
            "opportunityamount": "20000"
        }'
        </code>
</pre>     
                        </li>
                        <li><strong>Card-5: </strong>Add a nested resource /product to top level /opportunity resource and add the POST endpoint to create the opportunity products.
<pre>
    <code>
        Saito Family Laundromats

        curl --location 'http://localhost:8081/api/opportunity/product' \
        --header 'Content-Type: application/json' \
        --data '{
            "opportunityname": "Saito - Ground-mounted Panels",
            "products": [
                {
                    "productcode": "SPG-01",
                    "quantity": 35
                },
                {
                    "productcode": "SPG-02",
                    "quantity": 20
                }
            ]
        }'
        </code>
</pre>
<pre>
    <code>
        Boy Scout

        curl --location 'http://localhost:8081/api/opportunity/product' \
        --header 'Content-Type: application/json' \
        --data '{
            "opportunityname": "BSofSW - Ground-mounted Panels",
            "products": [
                {
                    "productcode": "SPG-02",
                    "quantity": 20
                }
            ]
        }'
        </code>
</pre>     
                        </li>
                        <li><strong>Card-6: </strong>Add a removeproduct to /opportunity /product resource and add the POST endpoint to remove  the opportunity products. With this method one can test adding and removing products multiple times from Postman.
<pre>
    <code>
curl --location 'http://localhost:8081/api/opportunity/removeproduct' \
--header 'Content-Type: application/json' \
--data '{
    "opportunityname": "Saito - Ground-mounted Panels",
    "products": [
        {
            "productcode": "SPG-01",
            "quantity": 35
        },
        {
            "productcode": "SPG-02",
            "quantity": 20
        }
    ]
}'
</code>
</pre>     
                        </li>
                        <li><strong>Card-7: </strong>August Release.</li>
                </ul>
            </div>
        </div>
    </div>
</div>
<div class="grooveborder">
    <ul><h6 class="text-center">Helpful Links<span class="alignright"></h6>
        <li><a href="https://www.youtube.com/watch?v=rvigMkg8MYo" target="_blank">Agile Scrum Sessions with Dr. Jeff Sutherland | Value Stream Management</a></li>
        <li><a href="https://www.youtube.com/watch?v=Yto8nUeki-s" target="_blank">What is Value Stream Management? (Eric, IBM Cloud)</a></li>
    </ul>   
</div>