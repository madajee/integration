<div class = "container-fluid mt-2">
    <div class="row">
        <integration-side-menu></integration-side-menu>
        <div class="col-md-10">
            <h6 class="text-center">INTEGRATION 111</h6>
            <p>Docker- It has been almost a decade when Docker build a container runtime build on Linux features and standardize the container image format to solve problem of packaging & distributing container images at scale by creating docker registry.</p>
            <p>Kubernetes - As Google guys were using containers for a long time, they had Borg which was incubated as a open source project as Kubernetes. Soon it became the defacto standard for container orchestration platform and all 3 public cloud proivders (GCP, Azure, AWS) create a service that will let you spin Kubernetes Cluster without provisioning any infrastructure & software licenses.</p>
            <p>Kubernetes along with Docker & several other related techlogies like Service Mesh and cloud computing is leading the way for enterprise grade microservices implementations at scale. I am also hoping to join this transformtative journer with a quick starter on Kubernetes ! </p>
            <h3>Kubernetes Starter</h3>
            <p>We are mostly familiar with the deployment targets as Virtual Machine but as the unit of deployment changes from VM to containers, we need a management layer that manages the cluster of nodes which run the containerized microservices application. As per official documentation (https://kubernetes.io/docs/concepts/overview/), Kubernetes provides you these features: Service discovery and load balancing, Storage Orchestration, Automated rollouts and rollbacks, Automatic bin packing, Self-healing, Secret Configuration Management. It also states that when you deploy Kubernetes, you get a cluster which consists of a set of worker machines, called nodes that run containerized applications. Kubernetes Cluster has a control plane that manages the worker nodes and Pods in a cluster. The core of Control Plane is an API server which exposes HTTP API and there is a kubectl command line interface which in-turn uses the API and let you query and manipulate the state of API Objects (Pods, Namespaces, ConfigMaps etc) in Kubernetes.</p>
            <p>The state of Kubernetes cluster can be represented with the objects persisted in it. Almost every Kubernetes object includes two nested object fields that govern the object's configuration: object spec and object status. Whether you use the Kubectl or UI, you will use the Kubernetes API to create, modify and delete Kubernetes objects. Some of the common kinds of Kubernetes objects are Pods, ReplicaSets, Services, Secrets, ConfigMaps, Deployments, Jobs, DaemonSets.</p>
            <p>Pods is a unit of deployment in Kubernetes and usually group one or more containers that are need to colocated and scaled simultaneously. Containers in the same Pod share the same hostname (IP Address) and namespace. Labels and Selectors allows Kubernetes Control Plane to discover the Kubernetes objects as a group and perform common tasks on it as directed by Kubernetes API. Services allow you to expose Pods through internal and external endpoints. Replication Controller allows control plane to maintain the desired number of Pods in a cluster and keeps your application highly available.</p>
            <p>A workload is an application running in Kubernetes and it can either be a single Pod or several Pods that work together to deliver the desired application features. Some Kubernetes objects apply a controller pattern and implements a control loop that makes the cuurent state closer to the desired state. ReplicaSet, though providers same feature as replication controller and maintains the stable set of replica Pods running at any given time, are successor to replication controller. Replica Set also guarantee the availability of a specified number of identical pods and allows you to use set based selectors & many different opertors to provide granular control on selection of Pods. As the workloads changes across different releases, it becomes quite cumbersome to directly manage relica sets, pods & other objects and deployment teams expect Kubernetes to support rollback, auto scaling, canary usecases. With Deployment object, one can declaratively define the desired state of the application (Pods and Replica Set) and Deployment Controller changes the actual state to deisred state at the controlled rate.</p>
        </div>
    </div>
</div>
<custom-footer authorname='Jeetan' linkurl='https://www.linkedin.com/in/jeetan-madaan-37aaa113/'></custom-footer>